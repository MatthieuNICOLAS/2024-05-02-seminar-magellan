\section{Synchronisation Models}

\begin{frame}{Synchronisation Models}
    \metroset{block=transparent}
    \begin{block}{To converge}
        \begin{itemize}
            \item Nodes have to propagate changes \dots
            \item \dots And integrate those of others
        \end{itemize}
    \end{block}

    \begin{block}{Several approaches proposed \cite{shapiro_2011_crdt}}
        \begin{itemize}
            \item State-based synchronisation
            \item Operation-based synchronisation
            \item<2->
                \only<2> {Delta-based synchronisation \cite{Almeida_2018}}
                \only<3> {\color{gray} Delta-based synchronisation \cite{Almeida_2018}}
            \only<2-3>{
                \begin{itemize}
                    \item
                        \only<2>{"Best of the two worlds" approach}
                        \only<3>{\color{gray} "Best of the two worlds" approach}
                \end{itemize}
            }
        \end{itemize}
    \end{block}
\end{frame}


\begin{frame}{An apartÃ© about lattice theory}
    \metroset{block=transparent}

    \begin{block}{Properties of join-semilattices}
        \begin{itemize}
            \item States of the join-semilattices are partially ordered according to relation $\leq$
            \item Updates produce new states by inflation, i.e. greater to previous ones according to $\leq$
            \item Exists a function $\trm{join}$ that, given any pair of states, generates the minimal state greater or equal to both given states according to $\leq$
            \item Exists a set of minimal states of the join-semilattice, the \emph{irreducible elements}
        \end{itemize}
    \end{block}
\end{frame}

\subsection{State-based CRDTs}

\begin{frame}{State-based synchronisation}
    \metroset{block=transparent}

    \begin{itemize}
        \item \alert{Send periodically current state} to other nodes
    \end{itemize}

    \begin{figure}[!ht]

        \centering
        \resizebox{\columnwidth}{!}{
          \begin{tikzpicture}
            \path
                node {\textbf{A}}
                ++(0:0.5) node (a) {}
                +(0:13) node (a-end) {}
                +(0:1) node[point, label=above right:{$\set{a,e}$}] (a-initial) {}
                +(0:3.5) node[point, label=above right:{$\set{a,b,e}$}, label=-170:{$\trm{add}(b)$}] (a-add-b) {}
                +(0:6) node[point, label=above right:{$\set{a,b,c,e}$}, label=-170:{$\trm{add}(c)$}] (a-add-c) {}
                +(0:8.5) node[point, label=below left:{$\trm{sync}$}, label={[xshift=10pt]-10:{$\set{a,b,c,e}$}}] (a-sends-state) {}
                +(0:11.5) node[point, label=above right:{$\set{a,b,c,d,e}$}] (a-final) {};

            \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
            \draw[->, thick] (a-initial) --  (a-add-b) -- (a-add-c) -- (a-sends-state) -- (a-final);

            \path
                ++(270:2) node {\textbf{B}}
                ++(0:0.5) node (b) {}
                +(0:13) node (b-end) {}
                +(0:1) node[point, label=below right:{$\set{a,e}$}] (b-initial) {}
                +(0:3.5) node[point, label=below right:{$\set{a,d,e}$}, label=170:{$\trm{add}(d)$}] (b-add-d) {}
                +(0:8.5) node[point, label=170:{$\trm{sync}$}, label={[xshift=15pt]10:{$\set{a,d,e}$}}] (b-sends-state) {}
                +(0:11.5) node[point, label=below right:{$\set{a,b,c,d,e}$}] (b-final) {};

            \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
            \draw[->, thick] (b-initial) --  (b-add-d) -- (b-sends-state) -- (b-final);

            \draw[->, dashed, shorten >= 1] (a-sends-state) -- (b-final);
            \draw[->, dashed, shorten >= 1] (b-sends-state) -- (a-final);
          \end{tikzpicture}
        }
    \end{figure}

    \begin{itemize}
        \item Upon reception, \alert{computes new state by merging received state with current one} using \texttt{merge} function
        \item With \texttt{merge}, a \alert{commutative, associative and idempotent function}
    \end{itemize}
\end{frame}

\begin{frame}{State-based synchronisation - ???}
    \metroset{block=transparent}

    \begin{block}{Strengths}
        \begin{itemize}
            \item No assumptions on the network reliability
            \item i.e. messages may be lost, re-ordered or duplicated w/o impact
        \end{itemize}
    \end{block}
    \begin{block}{Limits}
        \begin{itemize}
            \item States difficult to design
            \begin{itemize}
                \item e.g. how to represent efficiently deletion of elements?
            \end{itemize}
            \item States expensive to broadcast
            \item \texttt{merge} expensive
        \end{itemize}
    \end{block}
\end{frame}

\subsection{Operation-based CRDTs}

\begin{frame}{Operation-based synchronisation}
    \begin{itemize}
        \item \alert{Encode updates as arbitrary messages}, called \emph{operations}
        \item An operation \alert{correponds to one or several irreducible elements}
    \end{itemize}

    \begin{figure}[!ht]

        \centering
        \resizebox{\columnwidth}{!}{
          \begin{tikzpicture}
            \path
                node {\textbf{A}}
                ++(0:0.5) node (a) {}
                +(0:17) node (a-end) {}
                +(0:1) node[point, label=above right:{$\set{a,e}$}] (a-initial) {}
                +(0:3.5) node[point, label=above right:{$\set{a,b,e}$}, label=-170:{$\trm{add}(b)$}] (a-add-b) {}
                +(0:6) node[point, label=above right:{$\set{a,b,c,e}$}, label=-170:{$\trm{add}(c)$}] (a-add-c) {}
                +(0:8.5) node[point, label=above right:{$\set{a,b,c,d,e}$}] (a-receives-add-d) {}
                +(0:13.5) node[point, label={[xshift=8pt]-10:{$\trm{add(b)}$}}] (a-receives-query-sync) {}
                +(0:16) node (a-final) {};

            \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
            \draw[->, thick] (a-initial) --  (a-add-b) -- (a-add-c) -- (a-receives-add-d) -- (a-receives-query-sync) -- (a-final);

            \path
                ++(270:3) node {\textbf{B}}
                ++(0:0.5) node (b) {}
                +(0:17) node (b-end) {}
                +(0:1) node[point, label=below right:{$\set{a,e}$}] (b-initial) {}
                +(0:6) node[point, label=below right:{$\set{a,d,e}$}, label=170:{$\trm{add}(d)$}] (b-add-d) {}
                +(0:8.5) node[point, label=below right:{$\set{a,c,d,e}$}] (b-receives-add-c) {}
                +(0:11) node[point, label=170:{$\trm{query\ sync}$}] (b-sends-query-sync) {}
                +(0:16) node[point, label=below right:{$\set{a,b,c,d,e}$}] (b-final) {};

            \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
            \draw[->, thick] (b-initial) --  (b-add-d) -- (b-receives-add-c) -- (b-sends-query-sync) -- (b-final);

            \draw[->, dashed, shorten >= 1] (a-add-c) -- (b-receives-add-c);
            \draw[->, dashed, shorten >= 1] (b-add-d) -- (a-receives-add-d);
            \draw[->, dashed, shorten >= 1] (b-sends-query-sync) -- (a-receives-query-sync);
            \draw[->, dashed, shorten >= 1] (a-receives-query-sync) -- (b-final);

            \path
              ++(270:1.5)
              ++(0:0.5)
              +(0:4.75) node[cross] (network-error) {};

            \draw[->, dashed, shorten >= 1] (a-add-b) -- (network-error);
          \end{tikzpicture}
        }
      \end{figure}

    \begin{itemize}
        \item Upon reception, \alert{apply operations on current state}
        \item \alert{Concurrent operations} must be \alert{commutative}
    \end{itemize}
\end{frame}

\begin{frame}{Operation-based synchronisation - ???}
    \metroset{block=transparent}

    \begin{block}{Strengths}
        \begin{itemize}
            \item Designing operations is straightforward
            \item Operations usually cheap to broadcast and apply
        \end{itemize}
    \end{block}
    \begin{block}{Limits}
        \begin{itemize}
            \item Hides/delegates complexity to delivery of operations
            \begin{itemize}
                \item i.e. requires specific delivery order of operations
                \item e.g. insertion of an element before its deletion
            \end{itemize}
            \item Have to pair Op-based CRDTs with a delivery service to handle network failures
            \begin{itemize}
                \item To re-order and/or de-duplicate operations
                \item To retrieve lost operations using anti-entropy mechanisms
            \end{itemize}
        \end{itemize}
    \end{block}
\end{frame}